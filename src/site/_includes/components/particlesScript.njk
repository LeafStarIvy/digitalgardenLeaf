{# components/particlesScript.njk - FINAL: Multi-color streaks + cluster bursts + drifts #}
<script>
/* Cosmic Particles - layered canvas starfield with:
   • multicolor shooting stars
   • cluster explosion bursts
   • cluster drifts (groups spawned off-screen)
   • performant, DPR-aware, respects prefers-reduced-motion
*/
(function(){
  'use strict';

  const CONFIG = {
    stars: { desktop: 420, mobile: 120 },
    starbits: { desktop: 120, mobile: 36 },
    shooting: {
      minInterval: 3000,
      maxInterval: 7000,
      chancePerInterval: 0.75,
      minDuration: 1400,
      maxDuration: 4200,
      multicolorChance: 0.25,        // percent of shooting stars that are multicolor
      accentPalettes: [
        [45, 95, 58],   // gold
        [280, 80, 64],  // magenta
        [185, 85, 56]   // cyan
      ]
    },
    cluster: {
      chance: 0.06,        // chance per interval to spawn a cluster burst
      pieces: { min: 9, max: 18 },
      burstDuration: 900,  // ms for explosion expansion
      driftCount: { min: 3, max: 7 }, // leftover drifters spawned after burst
      driftLifetime: 9000
    },
    starTwinkleScale: 0.85
  };

  const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // Utilities
  const rand = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const isMobile = () => window.innerWidth <= 900;
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

  // Start on DOM ready
  document.addEventListener('DOMContentLoaded', () => {
    ['galaxySkybox','galaxySkyboxNote'].forEach(id=>{
      const el = document.getElementById(id);
      if (el) initSkybox(el);
    });
  });

  function initSkybox(wrapper) {
    if (!wrapper || wrapper._pgInit) return;
    wrapper._pgInit = true;

    // Ensure wrapper is positioned for canvases
    wrapper.style.position = wrapper.style.position || 'fixed';
    wrapper.style.inset = wrapper.style.inset || '0';
    wrapper.style.pointerEvents = 'none';

    // create canvases (bg/mid/fg)
    const layers = {
      bg: createCanvas('pg-canvas pg-canvas--bg'),
      mid: createCanvas('pg-canvas pg-canvas--mid'),
      fg: createCanvas('pg-canvas pg-canvas--fg')
    };
    wrapper.appendChild(layers.bg.canvas);
    wrapper.appendChild(layers.mid.canvas);
    wrapper.appendChild(layers.fg.canvas);

    // nebula nodes for parallax if present
    const nebBack = wrapper.querySelector('.nebula--back');
    const nebMid  = wrapper.querySelector('.nebula--mid');
    const nebFront= wrapper.querySelector('.nebula--front');

    // offscreen glow sprite
    let glowSprite = makeGlowSprite();

    // particle arrays
    let farStars = [], twinkleStars = [], starbits = [];
    let shootingStars = [], clusterBursts = [], clusterDrifts = [];

    // sizing
    let w = Math.max(wrapper.clientWidth || window.innerWidth, 800);
    let h = Math.max(wrapper.clientHeight || window.innerHeight, 400);
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    function resizeAll(){
      w = Math.max(wrapper.clientWidth || window.innerWidth, 800);
      h = Math.max(wrapper.clientHeight || window.innerHeight, 400);
      DPR = Math.max(1, window.devicePixelRatio || 1);
      resizeCanvas(layers.bg, w, h, DPR);
      resizeCanvas(layers.mid, w, h, DPR);
      resizeCanvas(layers.fg, w, h, DPR);
      glowSprite = makeGlowSprite(Math.round(30 * DPR));
      initParticles();
    }

    function initParticles(){
      const starCount = isMobile() ? CONFIG.stars.mobile : CONFIG.stars.desktop;
      const bitCount  = isMobile() ? CONFIG.starbits.mobile : CONFIG.starbits.desktop;

      farStars = Array.from({length: starCount}, ()=>({
        x: Math.random()*w, y: Math.random()*h, z: Math.random(),
        size: rand(0.28,1.9), baseA: rand(0.12,0.85),
        twPhase: Math.random()*Math.PI*2,
        hueOffset: Math.random() < 0.06 ? rand(-22,22) : 0
      }));

      twinkleStars = Array.from({length: Math.round(starCount*0.36)}, ()=>({
        x: Math.random()*w, y: Math.random()*h,
        size: rand(0.6,2.2), baseA: rand(0.22,0.95),
        twPhase: Math.random()*Math.PI*2, orbitPhase: Math.random()*Math.PI*2
      }));

      starbits = Array.from({length: bitCount}, ()=>({
        cx: rand(w*0.18, w*0.82),
        cy: rand(h*0.12, h*0.64),
        orbit: rand(18,170),
        angle: Math.random()*Math.PI*2,
        speed: rand(0.0006,0.0026),
        size: rand(0.9,3.6),
        wobble: rand(0.05,0.9),
        hue: Math.random() < 0.12 ? CONFIG.shooting.accentPalettes[Math.floor(Math.random()*CONFIG.shooting.accentPalettes.length)] : [210,70,62],
        extraPulse: Math.random()*Math.PI*2
      }));
    }

    // glow sprite
    function makeGlowSprite(size=30){
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const r = size/2;
      const g = ctx.createRadialGradient(r,r,0,r,r,r);
      g.addColorStop(0, 'rgba(255,255,255,0.98)');
      g.addColorStop(0.14, 'rgba(255,255,255,0.84)');
      g.addColorStop(0.36, 'rgba(140,170,255,0.28)');
      g.addColorStop(0.68, 'rgba(70,120,220,0.06)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,size,size);
      return c;
    }

    // DRAW FUNCTIONS
    function drawFar(now, ctx){
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      const driftX = Math.sin(now / 180000) * 14;
      const driftY = Math.cos(now / 150000) * 9;
      for (let s of farStars){
        const tw = prefersReduced ? 0 : Math.sin(now * (0.0009 + s.z*0.0009) + s.twPhase) * 0.36;
        const a = clamp(s.baseA + tw * CONFIG.starTwinkleScale, 0.06, 1);
        const scaled = s.size * (1 + s.z * 0.66);
        if (s.hueOffset !== 0){
          const h = 210 + s.hueOffset;
          ctx.fillStyle = `hsla(${h},75%,${60-Math.abs(s.hueOffset)}%,${a})`;
          ctx.beginPath();
          ctx.arc(s.x + driftX, s.y + driftY, scaled*0.9, 0, Math.PI*2);
          ctx.fill();
        } else {
          ctx.drawImage(glowSprite, Math.round(s.x + driftX - scaled*4), Math.round(s.y + driftY - scaled*4), scaled*8, scaled*8);
        }
      }
      ctx.restore();
    }

    function drawTwinkles(now, ctx){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const s of twinkleStars){
        const pulse = prefersReduced ? 0 : Math.sin(now * (0.0012 + 0.0005 * s.size) + s.twPhase) * 0.5;
        const a = clamp(s.baseA + pulse, 0.1, 1);
        const size = s.size * (1 + 0.12 * Math.sin(now / 600 + s.orbitPhase));
        ctx.globalAlpha = a;
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(s.x, s.y, size, 0, Math.PI*2);
        ctx.fill();
        ctx.drawImage(glowSprite, Math.round(s.x - size*3.2), Math.round(s.y - size*3.2), size*6.4, size*6.4);
      }
      ctx.restore();
    }

    function drawStarbits(now, ctx){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const b of starbits){
        b.angle += b.speed * (prefersReduced ? 0.2 : 1.0);
        const px = b.cx + Math.cos(b.angle) * b.orbit + Math.sin(now / 2000 + b.extraPulse) * b.wobble * 6;
        const py = b.cy + Math.sin(b.angle * 0.9) * b.orbit * 0.6 + Math.cos(now / 1400 + b.extraPulse) * b.wobble * 6;
        const pulse = prefersReduced ? 0.6 : (0.6 + Math.sin(now / 480 + b.extraPulse) * 0.35);
        const size = b.size * pulse;

        const hueArr = b.hue;
        const fill = `hsla(${hueArr[0]}, ${hueArr[1]}%, ${hueArr[2]}%, 1)`;

        ctx.save();
        ctx.translate(px, py);
        ctx.rotate((now/8000 + b.angle) % (Math.PI*2));
        ctx.beginPath();
        ctx.moveTo(0, -size);
        ctx.lineTo(size*0.6, 0);
        ctx.lineTo(0, size);
        ctx.lineTo(-size*0.6, 0);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.stroke();
        ctx.drawImage(glowSprite, -size*4.4, -size*4.4, size*8.8, size*8.8);
        ctx.restore();
      }
      ctx.restore();
    }

    // SHOOTING STARS (fg canvas) - now with multicolor gradient
    function spawnShooting(){
      if (prefersReduced) return;

      const startX = -rand(0.05*w, 0.18*w);
      const startY = rand(0.03*h, 0.6*h);
      const angleDeg = rand(18,55);
      const angle = angleDeg * (Math.PI/180);
      const endX = w + rand(0.05*w, 0.25*w);
      const dx = endX - startX;
      const endY = startY + Math.tan(angle) * dx;
      const duration = clamp(rand(CONFIG.shooting.minDuration, CONFIG.shooting.maxDuration), CONFIG.shooting.minDuration, CONFIG.shooting.maxDuration);

      // color type
      const isAccent = Math.random() < CONFIG.shooting.multicolorChance;
      const accent = isAccent ? CONFIG.shooting.accentPalettes[Math.floor(Math.random()*CONFIG.shooting.accentPalettes.length)] : null;

      shootingStars.push({
        sx: startX, sy: startY, ex: endX, ey: endY,
        life: 0, duration,
        headSize: rand(1.8,5.2),
        length: rand(120,450),
        stroke: clamp(rand(1.2,4.2),1.0,6.0),
        accent,
        isAccent
      });
    }

    function updateShooting(delta){
      for (let i = shootingStars.length-1; i>=0; i--){
        const s = shootingStars[i];
        s.life += delta;
        if (s.life > s.duration * 1.12) shootingStars.splice(i,1);
      }
    }

    function drawShooting(ctx){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const s of shootingStars){
        const progress = clamp(s.life / s.duration, 0, 1);
        const eased = easeOutCubic(progress);
        const hx = s.sx + (s.ex - s.sx) * eased;
        const hy = s.sy + (s.ey - s.sy) * eased;

        const dirX = hx - s.sx, dirY = hy - s.sy;
        const len = Math.hypot(dirX, dirY) || 1;
        const nx = dirX / len, ny = dirY / len;
        const tailX = hx - nx * s.length * (0.28 + 0.72*(1 - eased));
        const tailY = hy - ny * s.length * (0.28 + 0.72*(1 - eased));

        // gradient: transparent -> accent-ish (if accent) -> white head
        const grad = ctx.createLinearGradient(tailX, tailY, hx, hy);
        if (s.isAccent && s.accent) {
          const [h,sat,l] = s.accent;
          const col = `hsla(${h}, ${sat}%, ${l}%, 0.28)`;
          grad.addColorStop(0.0, 'rgba(255,255,255,0.0)');
          grad.addColorStop(0.48, col);
          grad.addColorStop(0.88, 'rgba(255,255,255,0.55)');
          grad.addColorStop(1.0, 'rgba(255,255,255,0.98)');
        } else {
          grad.addColorStop(0.0, 'rgba(255,255,255,0.0)');
          grad.addColorStop(0.6, 'rgba(255,255,255,0.22)');
          grad.addColorStop(1.0, 'rgba(255,255,255,0.98)');
        }

        ctx.strokeStyle = grad;
        ctx.lineWidth = s.stroke;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(hx, hy);
        ctx.stroke();

        // head: if accent, draw faint colored halo plus white core
        if (s.isAccent && s.accent) {
          const [h,sat,l] = s.accent;
          ctx.fillStyle = `hsla(${h}, ${sat}%, ${l}%, 0.95)`;
          ctx.beginPath();
          ctx.arc(hx, hy, s.headSize * 1.1, 0, Math.PI*2);
          ctx.fill();
          // white core
          ctx.fillStyle = 'rgba(255,255,255,0.96)';
          ctx.beginPath();
          ctx.arc(hx, hy, s.headSize * 0.6, 0, Math.PI*2);
          ctx.fill();
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.96)';
          ctx.beginPath();
          ctx.arc(hx, hy, s.headSize, 0, Math.PI*2);
          ctx.fill();
        }

        // sprite glow
        const gs = Math.max(18, s.headSize * 7);
        ctx.drawImage(glowSprite, hx - gs/2, hy - gs/2, gs, gs);
      }
      ctx.restore();
    }

    // CLUSTER BURSTS: explosion + drifters
    function spawnClusterBurst() {
      if (prefersReduced) return;
      // center on-screen region
      const cx = rand(w*0.2, w*0.78);
      const cy = rand(h*0.12, h*0.6);
      const pieces = Math.floor(rand(CONFIG.cluster.pieces.min, CONFIG.cluster.pieces.max + 1));
      const burst = {
        x: cx, y: cy,
        pieces: [],
        start: performance.now(),
        duration: CONFIG.cluster.burstDuration
      };

      for (let i=0;i<pieces;i++){
        const angle = Math.random()*Math.PI*2;
        const speed = rand(0.75, 3.6) * (w/1400);
        const life = rand(600, 1600);
        const size = rand(1.2, 4.0);
        const accent = Math.random() < 0.45 ? CONFIG.shooting.accentPalettes[Math.floor(Math.random()*CONFIG.shooting.accentPalettes.length)] : [210,70,62];
        burst.pieces.push({
          x: cx, y: cy,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0, duration: life,
          size, hue: accent
        });
      }

      clusterBursts.push(burst);

      // schedule cluster drifts (leftover groups that travel across) - spawn after a short delay
      const drifts = Math.floor(rand(CONFIG.cluster.driftCount.min, CONFIG.cluster.driftCount.max+1));
      setTimeout(()=> spawnClusterDriftsFrom(cx, cy, drifts), 420 + Math.random()*800);
    }

    function spawnClusterDriftsFrom(bx, by, count){
      // spawn small groups off-screen to the left that will move roughly in same direction as burst pieces
      for (let g=0; g<count; g++){
        // pick a leader direction roughly downward-right
        const angle = rand(18, 50) * (Math.PI/180);
        const speed = rand(0.12, 0.45) * (w/1400);
        // start left of screen (off-screen)
        const startX = -rand(0.06*w, 0.18*w);
        const startY = clamp(by + rand(-60, 60), 0, h);
        // group of bits travelling closely
        const groupSize = Math.floor(rand(3,7));
        const members = [];
        for (let i=0;i<groupSize;i++){
          members.push({
            x: startX - rand(0, 80), y: startY + rand(-24,24),
            vx: Math.cos(angle) * speed * (1 + rand(-0.18,0.18)),
            vy: Math.sin(angle) * speed * (1 + rand(-0.18,0.18)),
            size: rand(0.9,2.6),
            hue: CONFIG.shooting.accentPalettes[Math.floor(Math.random()*CONFIG.shooting.accentPalettes.length)],
            life: 0, duration: CONFIG.cluster.driftLifetime * (0.9 + Math.random()*0.4)
          });
        }
        clusterDrifts.push({ members });
      }
    }

    function updateClusters(delta){
      // bursts: move pieces, fade and remove when done
      for (let i = clusterBursts.length - 1; i >= 0; i--){
        const burst = clusterBursts[i];
        burst.pieces.forEach(p => {
          p.x += p.vx * (delta/16);
          p.y += p.vy * (delta/16);
          p.life += delta;
        });
        // remove pieces that exceed duration
        burst.pieces = burst.pieces.filter(p => p.life < p.duration);
        // if no pieces left, remove burst
        if (burst.pieces.length === 0) clusterBursts.splice(i,1);
      }

      // drifts: update each group's members
      for (let i = clusterDrifts.length - 1; i >= 0; i--){
        const g = clusterDrifts[i];
        for (let m of g.members){
          m.x += m.vx * (delta/16);
          m.y += m.vy * (delta/16);
          m.life += delta;
        }
        // remove members out of bounds or expired
        g.members = g.members.filter(m => m.life < m.duration && m.x < w + 0.4*w && m.y > -0.4*h && m.y < h + 0.4*h);
        if (g.members.length === 0) clusterDrifts.splice(i,1);
      }
    }

    function drawClusters(ctx){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      // bursts: draw small radial particles with glow
      for (const burst of clusterBursts){
        for (const p of burst.pieces){
          const t = p.life / p.duration;
          const alpha = clamp(1 - t, 0, 1);
          const size = p.size * (1 + 0.6*(1 - t));
          ctx.fillStyle = `hsla(${p.hue[0]}, ${p.hue[1]}%, ${p.hue[2]}%, ${alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, Math.PI*2);
          ctx.fill();
          // small glow
          ctx.drawImage(glowSprite, p.x - size*3.6, p.y - size*3.6, size*7.2, size*7.2);
        }
      }

      // drifts: draw grouped bits that gently glow and travel
      for (const g of clusterDrifts){
        for (const m of g.members){
          const t = m.life / m.duration;
          const alpha = clamp(1 - t*0.9, 0.06, 1);
          ctx.fillStyle = `hsla(${m.hue[0]}, ${m.hue[1]}%, ${m.hue[2]}%, ${alpha})`;
          ctx.beginPath();
          ctx.arc(m.x, m.y, m.size, 0, Math.PI*2);
          ctx.fill();
          ctx.drawImage(glowSprite, m.x - m.size*3.8, m.y - m.size*3.8, m.size*7.6, m.size*7.6);
        }
      }

      ctx.restore();
    }

    // frame loop
    let last = performance.now();
    let rafId = null;
    let lastSpawn = performance.now();
    let nextSpawn = rand(CONFIG.shooting.minInterval, CONFIG.shooting.maxInterval);

    function frame(now){
      const delta = Math.min(40, now - last);
      last = now;

      // clear canvases
      layers.bg.ctx.clearRect(0,0,w,h);
      layers.mid.ctx.clearRect(0,0,w,h);
      layers.fg.ctx.clearRect(0,0,w,h);

      drawFar(now, layers.bg.ctx);
      drawTwinkles(now, layers.mid.ctx);
      drawStarbits(now, layers.mid.ctx);

      // update & draw shooting
      updateShooting(delta);
      drawShooting(layers.fg.ctx);

      // update clusters
      updateClusters(delta);
      drawClusters(layers.fg.ctx);

      // spawn logic: shooting stars & cluster bursts & cluster drifts
      if (!prefersReduced && (now - lastSpawn > nextSpawn)) {
        // possibly spawn multicolor shooting
        if (Math.random() < CONFIG.shooting.chancePerInterval) {
          // sometimes spawn cluster bursts instead of single shooting star
          if (Math.random() < CONFIG.cluster.chance) {
            spawnClusterBurst();
          } else {
            spawnShooting();
          }
        }
        lastSpawn = now;
        nextSpawn = rand(CONFIG.shooting.minInterval, CONFIG.shooting.maxInterval);
      }

      // also maintain occasional gentle cluster drifts (background)
      if (!prefersReduced && Math.random() < 0.006) {
        // spawn a passive drift group occasionally
        spawnClusterDriftsFrom(rand(0,w), rand(0,h), Math.floor(rand(2,5)));
      }

      rafId = requestAnimationFrame(frame);
    }

    // Parallax pointer-based
    let tx = 0, ty = 0, px = 0, py = 0;
    function onPointer(e){
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      tx = (cx / window.innerWidth - 0.5) * 2;
      ty = (cy / window.innerHeight - 0.5) * 2;
    }
    function parallaxLoop(){
      px += (tx - px) * 0.06;
      py += (ty - py) * 0.06;
      if (nebBack) nebBack.style.transform = `translate(${px*8}px, ${py*4}px) scale(1.04)`;
      if (nebMid)  nebMid.style.transform  = `translate(${px*14}px, ${py*7}px) scale(1.02)`;
      if (nebFront) nebFront.style.transform = `translate(${px*22}px, ${py*10}px) scale(1.01)`;
      requestAnimationFrame(parallaxLoop);
    }

    // interactivity: click -> small burst of starbits
    wrapper.addEventListener('pointerdown', (e)=> {
      if (prefersReduced) return;
      const rect = wrapper.getBoundingClientRect();
      const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
      for (let i=0;i<6;i++){
        starbits.push({
          cx: cx + rand(-26,26),
          cy: cy + rand(-26,26),
          orbit: rand(8,48),
          angle: Math.random()*Math.PI*2,
          speed: rand(0.002,0.01),
          size: rand(0.9,3.2),
          wobble: rand(0.05,0.5),
          hue: CONFIG.shooting.accentPalettes[Math.floor(Math.random()*CONFIG.shooting.accentPalettes.length)],
          extraPulse: Math.random()*Math.PI*2
        });
      }
      if (starbits.length > (CONFIG.starbits.desktop*3)) starbits.splice(0,18);
    }, {passive:true});

    // start/stop and housekeeping
    function start(){
      resizeAll();
      initParticles();
      last = performance.now();
      if (!prefersReduced) {
        rafId = requestAnimationFrame(frame);
        window.addEventListener('pointermove', onPointer, {passive:true});
        parallaxLoop();
      } else {
        frame(performance.now());
      }
      // fallback periodic spawn (in case RAF isn't precise)
      if (!prefersReduced) wrapper._shootTimer = setInterval(()=>{
        if (Math.random() < CONFIG.shooting.chancePerInterval) {
          if (Math.random() < CONFIG.cluster.chance) spawnClusterBurst(); else spawnShooting();
        }
      }, 4200);
    }

    window.addEventListener('resize', ()=> {
      clearTimeout(wrapper._resizeTO);
      wrapper._resizeTO = setTimeout(()=> resizeAll(), 140);
    });

    document.addEventListener('visibilitychange', ()=> {
      if (document.hidden) {
        if (rafId) cancelAnimationFrame(rafId); rafId = null;
      } else {
        if (!prefersReduced && !rafId) { last = performance.now(); rafId = requestAnimationFrame(frame); }
      }
    });

    window.addEventListener('beforeunload', ()=> {
      if (rafId) cancelAnimationFrame(rafId);
      if (wrapper._shootTimer) clearInterval(wrapper._shootTimer);
      window.removeEventListener('pointermove', onPointer);
    });

    // helpers: canvas creation & resize
    function createCanvas(cls){
      const c = document.createElement('canvas');
      c.className = cls;
      c.style.position = 'absolute';
      c.style.left = '0';
      c.style.top = '0';
      c.style.width = '100%';
      c.style.height = '100%';
      c.style.pointerEvents = 'none';
      const ctx = c.getContext('2d', { alpha: true });
      return { canvas: c, ctx };
    }
    function resizeCanvas(layer, width, height, dpr){
      const canvas = layer.canvas;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      layer.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // run
    start();
  }
})();
</script>
