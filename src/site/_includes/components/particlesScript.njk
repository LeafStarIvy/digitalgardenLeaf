{# components/particlesScript.njk - REGENERATED & FIXED FOR RELIABLE SHOOTING STARS #}
<script>
/* Particles: layered canvas starfield + starbits + robust shooting stars
   - Replaces earlier version; fixes the disappearing/flashing shooting stars
   - Shooting-stars travel full offscreen -> across -> offscreen path
   - Respects prefers-reduced-motion
   - Tunable CONFIG at top
*/
(function () {
  'use strict';

  const CONFIG = {
    stars: { desktop: 420, mobile: 120 },
    starbits: { desktop: 120, mobile: 36 },
    shooting: {
      minInterval: 3200,
      maxInterval: 7800,
      chancePerInterval: 0.65,
      minDuration: 1400,  // ms minimal travel time (shorter streaks)
      maxDuration: 4200   // ms maximal (long cinematic streaks)
    },
    colors: {
      baseHue: 210,
      accents: [
        [45, 95, 58],   // gold-ish
        [280, 80, 64],  // magenta-ish
        [185, 85, 56]   // cyan-ish
      ]
    },
    starTwinkleScale: 0.85
  };

  const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // Utilities
  const rand = (a, b) => a + Math.random() * (b - a);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const isMobile = () => window.innerWidth <= 900;
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

  // Create skyboxes for any galaxy container on page
  document.addEventListener('DOMContentLoaded', () => {
    const ids = ['galaxySkybox', 'galaxySkyboxNote'];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) initSkybox(el);
    });
  });

  function initSkybox(wrapper) {
    if (!wrapper || wrapper._pgInit) return;
    wrapper._pgInit = true;

    // Ensure wrapper has position
    wrapper.style.position = wrapper.style.position || 'fixed';
    wrapper.style.inset = wrapper.style.inset || '0';
    wrapper.style.pointerEvents = 'none';

    // Create canvases (bg, mid, fg)
    const canvases = {
      bg: createCanvas('pg-canvas pg-canvas--bg'),
      mid: createCanvas('pg-canvas pg-canvas--mid'),
      fg: createCanvas('pg-canvas pg-canvas--fg')
    };
    // z-index of canvases is determined in your CSS; we append here
    wrapper.appendChild(canvases.bg.canvas);
    wrapper.appendChild(canvases.mid.canvas);
    wrapper.appendChild(canvases.fg.canvas);

    // Nearest "nebula" elements (optional) are present in markup; used for parallax
    const nebBack = wrapper.querySelector('.nebula--back');
    const nebMid  = wrapper.querySelector('.nebula--mid');
    const nebFront = wrapper.querySelector('.nebula--front');

    // Prepare an offscreen glow sprite for fast repeated drawing
    let glowSprite = makeGlowSprite();

    // Particle arrays
    let farStars = [], twinkleStars = [], starbits = [], shootingStars = [];

    // size & DPR
    let w = Math.max(wrapper.clientWidth || window.innerWidth, 800);
    let h = Math.max(wrapper.clientHeight || window.innerHeight, 400);
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    function resizeAll() {
      w = Math.max(wrapper.clientWidth || window.innerWidth, 800);
      h = Math.max(wrapper.clientHeight || window.innerHeight, 400);
      DPR = Math.max(1, window.devicePixelRatio || 1);
      resizeCanvas(canvases.bg, w, h, DPR);
      resizeCanvas(canvases.mid, w, h, DPR);
      resizeCanvas(canvases.fg, w, h, DPR);
      glowSprite = makeGlowSprite(Math.round(28 * DPR));
      // re-init particles to fit new size
      initParticles();
    }

    // Initialize particle sets
    function initParticles() {
      const starCount = isMobile() ? CONFIG.stars.mobile : CONFIG.stars.desktop;
      const bitCount  = isMobile() ? CONFIG.starbits.mobile : CONFIG.starbits.desktop;

      farStars = new Array(starCount).fill(0).map(() => ({
        x: Math.random() * w,
        y: Math.random() * h,
        z: Math.random(),
        size: rand(0.28, 1.9),
        baseA: rand(0.12, 0.85),
        twPhase: Math.random() * Math.PI * 2,
        hueOffset: Math.random() < 0.06 ? rand(-22, 22) : 0
      }));

      twinkleStars = new Array(Math.round(starCount * 0.36)).fill(0).map(() => ({
        x: Math.random() * w,
        y: Math.random() * h,
        size: rand(0.6, 2.2),
        baseA: rand(0.22, 0.95),
        twPhase: Math.random() * Math.PI * 2,
        orbitPhase: Math.random() * Math.PI * 2
      }));

      starbits = new Array(bitCount).fill(0).map(() => {
        const cx = rand(w * 0.18, w * 0.82);
        const cy = rand(h * 0.12, h * 0.64);
        return {
          cx,
          cy,
          orbit: rand(18, 170),
          angle: Math.random() * Math.PI * 2,
          speed: rand(0.0006, 0.0026),
          size: rand(0.9, 3.6),
          wobble: rand(0.05, 0.9),
          hue: Math.random() < 0.12 ? CONFIG.colors.accents[Math.floor(Math.random()*CONFIG.colors.accents.length)] : [CONFIG.colors.baseHue, 70, 62],
          extraPulse: Math.random() * Math.PI * 2
        };
      });
    }

    // Glow sprite helper (radial gradient)
    function makeGlowSprite(size = 28) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const r = size / 2;
      const g = ctx.createRadialGradient(r, r, 0, r, r, r);
      g.addColorStop(0, 'rgba(255,255,255,0.98)');
      g.addColorStop(0.15, 'rgba(255,255,255,0.82)');
      g.addColorStop(0.35, 'rgba(120,160,255,0.28)');
      g.addColorStop(0.7, 'rgba(60,100,220,0.06)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, size, size);
      return c;
    }

    // Drawing functions
    function drawFar(now, ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      const driftX = Math.sin(now / 180000) * 14;
      const driftY = Math.cos(now / 150000) * 9;
      for (let s of farStars) {
        const tw = prefersReduced ? 0 : Math.sin(now * (0.0009 + s.z * 0.0009) + s.twPhase) * 0.36;
        const a = clamp(s.baseA + tw * CONFIG.starTwinkleScale, 0.06, 1);
        const scaled = s.size * (1 + s.z * 0.66);
        if (s.hueOffset !== 0) {
          const h = CONFIG.colors.baseHue + s.hueOffset;
          ctx.fillStyle = `hsla(${h}, 75%, ${60 - Math.abs(s.hueOffset)}%, ${a})`;
          // small colored glow
          ctx.beginPath();
          ctx.arc(s.x + driftX, s.y + driftY, scaled * 0.9, 0, Math.PI*2);
          ctx.fill();
        } else {
          // use glow sprite for subtle soft star
          ctx.drawImage(glowSprite, Math.round(s.x + driftX - scaled*4), Math.round(s.y + driftY - scaled*4), scaled * 8, scaled * 8);
        }
      }
      ctx.restore();
    }

    function drawTwinkles(now, ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const s of twinkleStars) {
        const pulse = prefersReduced ? 0 : Math.sin(now * (0.0012 + 0.0005 * s.size) + s.twPhase) * 0.5;
        const a = clamp(s.baseA + pulse, 0.1, 1);
        const size = s.size * (1 + 0.12 * Math.sin(now / 600 + s.orbitPhase));
        ctx.globalAlpha = a;
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(s.x, s.y, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.drawImage(glowSprite, Math.round(s.x - size * 3.2), Math.round(s.y - size * 3.2), size * 6.4, size * 6.4);
      }
      ctx.restore();
    }

    function drawStarbits(now, ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const b of starbits) {
        b.angle += b.speed * (prefersReduced ? 0.2 : 1.0);
        const px = b.cx + Math.cos(b.angle) * b.orbit + Math.sin(now / 2000 + b.extraPulse) * b.wobble * 6;
        const py = b.cy + Math.sin(b.angle * 0.9) * b.orbit * 0.6 + Math.cos(now / 1400 + b.extraPulse) * b.wobble * 6;
        const pulse = prefersReduced ? 0.6 : (0.6 + Math.sin(now / 480 + b.extraPulse) * 0.35);
        const size = b.size * pulse;

        // color
        const hueArr = b.hue;
        const fill = `hsla(${hueArr[0]}, ${hueArr[1]}%, ${hueArr[2]}%, 1)`;

        ctx.save();
        ctx.translate(px, py);
        ctx.rotate((now / 8000 + b.angle) % (Math.PI * 2));
        // diamond shape
        ctx.beginPath();
        ctx.moveTo(0, -size);
        ctx.lineTo(size * 0.6, 0);
        ctx.lineTo(0, size);
        ctx.lineTo(-size * 0.6, 0);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.stroke();

        // soft outer
        ctx.drawImage(glowSprite, -size * 4.4, -size * 4.4, size * 8.8, size * 8.8);
        ctx.restore();
      }
      ctx.restore();
    }

    // SHOOTING STARS (FG canvas): robust path & lifetime logic
    function spawnShooting() {
      if (prefersReduced) return;

      // start well off-screen left/top region
      const startX = -rand(0.05 * w, 0.18 * w);
      const startY = rand(0.03 * h, 0.6 * h);

      // choose a downward-right angle (in radians) that gives a pleasing diagonal
      const angleDeg = rand(18, 55);
      const angle = angleDeg * (Math.PI / 180);

      // set end X beyond the right edge (so full crossing)
      const endX = w + rand(0.05 * w, 0.25 * w);
      // compute distance horizontally
      const dx = endX - startX;
      // compute endY based on angle and dx
      const endY = startY + Math.tan(angle) * dx;

      const distance = Math.hypot(dx, endY - startY);
      // duration proportional to distance, clamped
      const duration = clamp(rand(CONFIG.shooting.minDuration, CONFIG.shooting.maxDuration), CONFIG.shooting.minDuration, CONFIG.shooting.maxDuration);

      // spawn object
      shootingStars.push({
        sx: startX, sy: startY,
        ex: endX, ey: endY,
        life: 0,
        duration,
        headSize: rand(1.6, 4.6),
        length: rand(120, 420),
        stroke: clamp(rand(1.2, 4.0), 1.0, 5.0)
      });
    }

    function updateShooting(delta) {
      // life increment, removal when progress>1.12
      for (let i = shootingStars.length - 1; i >= 0; i--) {
        const s = shootingStars[i];
        s.life += delta;
        if (s.life > s.duration * 1.12) shootingStars.splice(i, 1);
      }
    }

    function drawShooting(ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const s of shootingStars) {
        const progress = clamp(s.life / s.duration, 0, 1);
        // easing so they accelerate quickly and then coast
        const eased = easeOutCubic(progress);

        // lerp head position
        const hx = s.sx + (s.ex - s.sx) * eased;
        const hy = s.sy + (s.ey - s.sy) * eased;

        // compute tail position based on length and direction vector (closer to start)
        const dirX = hx - s.sx;
        const dirY = hy - s.sy;
        const len = Math.hypot(dirX, dirY) || 1;
        const nx = dirX / len;
        const ny = dirY / len;
        const tailX = hx - nx * s.length * (0.28 + 0.72 * (1 - eased)); // tail shortens slightly as it progresses
        const tailY = hy - ny * s.length * (0.28 + 0.72 * (1 - eased));

        // draw gradient trail from transparent tail -> bright head
        const grad = ctx.createLinearGradient(tailX, tailY, hx, hy);
        grad.addColorStop(0.0, 'rgba(255,255,255,0.0)');
        grad.addColorStop(0.55, 'rgba(255,255,255,0.22)');
        grad.addColorStop(1.0, 'rgba(255,255,255,0.98)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = s.stroke;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(hx, hy);
        ctx.stroke();

        // bright head
        ctx.fillStyle = 'rgba(255,255,255,0.96)';
        ctx.beginPath();
        ctx.arc(hx, hy, s.headSize, 0, Math.PI * 2);
        ctx.fill();

        // subtle head glow using sprite for bigger appearance
        const gs = Math.max(18, s.headSize * 7);
        ctx.drawImage(glowSprite, hx - gs/2, hy - gs/2, gs, gs);
      }
      ctx.restore();
    }

    // Frame loop
    let last = performance.now();
    let rafId = null;
    let lastSpawn = performance.now();
    let nextSpawnInterval = rand(CONFIG.shooting.minInterval, CONFIG.shooting.maxInterval);

    function frame(now) {
      const delta = Math.min(40, now - last); // clamp delta for stability
      last = now;

      // clear canvases
      canvases.bg.ctx.clearRect(0,0,w,h);
      canvases.mid.ctx.clearRect(0,0,w,h);
      canvases.fg.ctx.clearRect(0,0,w,h);

      // draw layers
      drawFar(now, canvases.bg.ctx);
      drawTwinkles(now, canvases.mid.ctx);
      drawStarbits(now, canvases.fg.ctx);

      // update/draw shooting stars on FG
      updateShooting(delta);
      drawShooting(canvases.fg.ctx);

      // spawn shooting stars periodically (if allowed)
      if (!prefersReduced && now - lastSpawn > nextSpawnInterval) {
        if (Math.random() < CONFIG.shooting.chancePerInterval) spawnShooting();
        lastSpawn = now;
        nextSpawnInterval = rand(CONFIG.shooting.minInterval, CONFIG.shooting.maxInterval);
      }

      rafId = requestAnimationFrame(frame);
    }

    // Parallax: subtle pointer-based translation of nebula layers
    let tx = 0, ty = 0, px = 0, py = 0;
    function onPointer(ev) {
      const cx = ev.touches ? ev.touches[0].clientX : ev.clientX;
      const cy = ev.touches ? ev.touches[0].clientY : ev.clientY;
      // Normalize to [-1,1]
      tx = (cx / window.innerWidth - 0.5) * 2;
      ty = (cy / window.innerHeight - 0.5) * 2;
    }
    function parallaxLoop() {
      px += (tx - px) * 0.06;
      py += (ty - py) * 0.06;
      if (nebBack) nebBack.style.transform = `translate(${px * 8}px, ${py * 4}px) scale(1.04)`;
      if (nebMid)  nebMid.style.transform  = `translate(${px * 14}px, ${py * 7}px) scale(1.02)`;
      if (nebFront) nebFront.style.transform = `translate(${px * 22}px, ${py * 10}px) scale(1.01)`;
      requestAnimationFrame(parallaxLoop);
    }

    // Start everything
    function start() {
      resizeAll();
      initParticles();
      last = performance.now();

      if (!prefersReduced) rafId = requestAnimationFrame(frame);
      else {
        // Render a single static frame for reduced-motion
        frame(performance.now());
      }

      // Pointer parallax
      if (!prefersReduced) {
        window.addEventListener('pointermove', onPointer, { passive: true });
        parallaxLoop();
      }

      // allow click bursts: small interactive starbit bursts
      wrapper.addEventListener('pointerdown', e => {
        if (prefersReduced) return;
        const r = wrapper.getBoundingClientRect();
        const cx = e.clientX - r.left;
        const cy = e.clientY - r.top;
        for (let i = 0; i < 6; i++) {
          starbits.push({
            cx: cx + rand(-26, 26),
            cy: cy + rand(-26, 26),
            orbit: rand(8, 48),
            angle: Math.random() * Math.PI * 2,
            speed: rand(0.002, 0.01),
            size: rand(0.9, 3.2),
            wobble: rand(0.05, 0.5),
            hue: CONFIG.colors.accents[Math.floor(Math.random() * CONFIG.colors.accents.length)],
            extraPulse: Math.random()*Math.PI*2
          });
        }
        // keep starbits array bounded
        if (starbits.length > (CONFIG.starbits.desktop * 3)) starbits.splice(0, 18);
      }, { passive: true });

      // periodic shooting star spawn via timer too (fallback)
      if (!prefersReduced) {
        wrapper._shootTimer = setInterval(() => {
          if (Math.random() < CONFIG.shooting.chancePerInterval) spawnShooting();
        }, 4200);
      }
    }

    // resize handling
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        resizeAll();
      }, 160);
    });

    // visibility handling
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      } else {
        if (!prefersReduced && !rafId) {
          last = performance.now();
          rafId = requestAnimationFrame(frame);
        }
      }
    });

    // cleanup on unload (SPA-safe)
    window.addEventListener('beforeunload', () => {
      if (rafId) cancelAnimationFrame(rafId);
      if (wrapper._shootTimer) clearInterval(wrapper._shootTimer);
      window.removeEventListener('pointermove', onPointer);
    });

    // helpers: canvas creation & resize
    function createCanvas(cls) {
      const c = document.createElement('canvas');
      c.className = cls;
      c.style.position = 'absolute';
      c.style.left = '0';
      c.style.top = '0';
      c.style.width = '100%';
      c.style.height = '100%';
      c.style.pointerEvents = 'none';
      // layer z-index handled by CSS classes
      const ctx = c.getContext('2d', { alpha: true });
      return { canvas: c, ctx };
    }
    function resizeCanvas(layer, width, height, dpr) {
      const canvas = layer.canvas;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      // scale context to device pixels
      layer.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // run
    start();
  }
})();
</script>
