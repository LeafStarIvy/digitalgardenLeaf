{# components/particlesScript.njk #}
<script>
/* =========================================================
   PARTICLES: layered canvas starfield + starbits + shooting stars
   - Single include used for index & note pages
   - Creates canvases inside `.galaxy-skybox` (or note-specific container)
   - Respects prefers-reduced-motion
   ========================================================= */
(function () {
  'use strict';

  // Config: tweak these at the top for density/speed/colors
  const CONFIG = {
    stars: { desktop: 420, mobile: 140 },
    starbits: { desktop: 96, mobile: 28 },
    shooting: { intervalMin: 3800, intervalMax: 7600, chance: 0.7 },
    colors: {
      primary: [210, 75, 60],   // bluish hue for base (h, sat, light)
      accents: [
        [45, 95, 55],  // gold
        [280, 80, 60], // magenta
        [185, 85, 55]  // cyan
      ]
    },
    starTwinkleSpeedScale: 0.8,
    maxCanvasFPS: 60
  };

  // Utility functions
  const rand = (a, b) => a + Math.random() * (b - a);
  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
  const isMobile = () => window.innerWidth <= 900;
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // Setup per-skybox container (support both main index and note pages)
  function setupSkybox(containerId) {
    const wrapper = document.getElementById(containerId);
    if (!wrapper) return;
    initSkybox(wrapper);
  }

  // Auto-detect all galaxy containers on the page
  document.addEventListener('DOMContentLoaded', () => {
    ['galaxySkybox', 'galaxySkyboxNote'].forEach(id => setupSkybox(id));
  });

  function initSkybox(wrapper) {
    // Avoid duplicate initializations
    if (wrapper._particlesInit) return;
    wrapper._particlesInit = true;

    // Create layered canvases
    const layers = {
      bg: createCanvas('pg-canvas pg-canvas--bg'),
      mid: createCanvas('pg-canvas pg-canvas--mid'),
      fg: createCanvas('pg-canvas pg-canvas--fg')
    };

    // append canvases to wrapper (bg first)
    wrapper.appendChild(layers.bg.canvas);
    wrapper.appendChild(layers.mid.canvas);
    wrapper.appendChild(layers.fg.canvas);

    // Ensure shooting-star container exists
    const shootContainer = wrapper.querySelector('.shooting-stars') || createShootingContainer(wrapper);

    // Nebula parallax: reference nebula elements in the wrapper
    const nebulaBack = wrapper.querySelector('.nebula--back');
    const nebulaMid = wrapper.querySelector('.nebula--mid');
    const nebulaFront = wrapper.querySelector('.nebula--front');

    // DPR & sizing
    let w = Math.max(window.innerWidth, 800);
    let h = Math.max(window.innerHeight, 400);
    let DPR = Math.max(1, window.devicePixelRatio || 1);
    function resize() {
      w = wrapper.clientWidth || Math.max(window.innerWidth, 800);
      h = wrapper.clientHeight || Math.max(window.innerHeight, 400);
      DPR = Math.max(1, window.devicePixelRatio || 1);
      resizeCanvas(layers.bg, w, h, DPR);
      resizeCanvas(layers.mid, w, h, DPR);
      resizeCanvas(layers.fg, w, h, DPR);
      // re-init sprite caches if needed
      prepareGlowSprite(Math.round(26 * DPR));
    }

    // Particle arrays
    let farStars = [];
    let twinkleStars = [];
    let starbits = [];
    let shootingStars = [];

    // Pre-rendered glow sprite for fast drawing
    let glowSprite = null;
    function prepareGlowSprite(size) {
      // small offscreen canvas with radial gradient for glow/star sprite
      const s = Math.max(12, size || 26);
      const c = document.createElement('canvas');
      c.width = c.height = s;
      const ctx = c.getContext('2d');
      const g = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
      g.addColorStop(0, 'rgba(255,255,255,0.98)');
      g.addColorStop(0.18, 'rgba(255,255,255,0.8)');
      g.addColorStop(0.36, 'rgba(120,160,255,0.28)');
      g.addColorStop(0.68, 'rgba(80,120,220,0.06)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,s,s);
      glowSprite = c;
    }
    prepareGlowSprite(Math.round(26 * DPR));

    // Initialize particle arrays depending on viewport
    function initParticles() {
      const starCount = isMobile() ? CONFIG.stars.mobile : CONFIG.stars.desktop;
      const bitCount = isMobile() ? CONFIG.starbits.mobile : CONFIG.starbits.desktop;

      farStars = new Array(starCount).fill(0).map(() => ({
        x: Math.random() * w,
        y: Math.random() * h,
        z: Math.random(), // depth
        size: rand(0.28, 1.9),
        baseA: rand(0.12, 0.85),
        twPhase: Math.random() * Math.PI * 2,
        hueOffset: Math.random() < 0.06 ? rand(-22, 22) : 0
      }));

      // twinkleStars are mid-layer slightly brighter
      twinkleStars = new Array(Math.round(starCount * 0.35)).fill(0).map(() => ({
        x: Math.random() * w,
        y: Math.random() * h,
        size: rand(0.6, 2.6),
        baseA: rand(0.22, 0.95),
        twPhase: Math.random() * Math.PI * 2,
        orbitPhase: Math.random() * Math.PI * 2
      }));

      starbits = new Array(bitCount).fill(0).map(() => {
        // bit orbits / float points over the field
        const cx = rand(w*0.2, w*0.8);
        const cy = rand(h*0.15, h*0.6);
        const orbit = rand(20, 160);
        const ang = Math.random() * Math.PI * 2;
        const colorPick = Math.random() < 0.12 ? CONFIG.colors.accents[Math.floor(Math.random()*CONFIG.colors.accents.length)] : CONFIG.colors.primary;
        return {
          cx, cy, orbit, angle: ang, speed: rand(0.0006, 0.0024),
          size: rand(0.9, 3.8),
          wobble: rand(0.05, 0.9),
          hue: colorPick, // [h,s,l]
          extraPulse: Math.random() * Math.PI * 2
        };
      });
    }

    // Drawing helpers
    function drawBackground(now, ctx) {
      // far stars: small dots using glow sprite for subtle shimmer
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      // slight motion for parallax of deep starfield
      const driftX = Math.sin(now/180000) * 12;
      const driftY = Math.cos(now/150000) * 8;
      for (let s of farStars) {
        const tw = prefersReduced ? 0 : Math.sin(now * (0.0009 + s.z*0.0009) + s.twPhase) * 0.36;
        const a = clamp(s.baseA + tw*CONFIG.starTwinkleSpeedScale, 0.08, 1);
        const scaledSize = s.size * (1 + s.z*0.6);
        // color mixing
        if (s.hueOffset !== 0) {
          const [h,sat,light] = CONFIG.colors.primary;
          ctx.fillStyle = `hsla(${h + s.hueOffset}, ${sat}%, ${light - 6}%, ${a})`;
        } else {
          ctx.fillStyle = `rgba(255,255,255,${a})`;
        }
        ctx.drawImage(glowSprite, Math.round(s.x + driftX - scaledSize*4), Math.round(s.y + driftY - scaledSize*4), scaledSize*8, scaledSize*8);
      }
      ctx.restore();
    }

    function drawTwinkle(now, ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (let s of twinkleStars) {
        const pulse = prefersReduced ? 0 : Math.sin(now * (0.0012 + 0.0005 * s.size) + s.twPhase) * 0.5;
        const a = clamp(s.baseA + pulse, 0.1, 1);
        const size = s.size * (1 + 0.12 * Math.sin(now/600 + s.orbitPhase));
        ctx.globalAlpha = a;
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(s.x, s.y, size, 0, Math.PI * 2);
        ctx.fill();
        // soft outer
        ctx.drawImage(glowSprite, Math.round(s.x - size*3.2), Math.round(s.y - size*3.2), size*6.4, size*6.4);
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // starbits are small diamond-style stars that orbit and twinkle â€” more alive (SMG-like)
    function drawStarBits(now, ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (let b of starbits) {
        b.angle += b.speed * (prefersReduced ? 0.2 : 1.0);
        const px = b.cx + Math.cos(b.angle) * b.orbit + Math.sin(now / 2000 + b.extraPulse) * b.wobble * 6;
        const py = b.cy + Math.sin(b.angle * 0.9) * b.orbit * 0.6 + Math.cos(now / 1400 + b.extraPulse) * b.wobble * 6;
        const pulse = prefersReduced ? 0 : (0.6 + Math.sin(now / 480 + b.extraPulse) * 0.35);
        const size = b.size * pulse;
        // color from hue array
        const hueArr = b.hue;
        let fill = `hsla(${hueArr[0]}, ${hueArr[1]}%, ${hueArr[2]}%, 1)`;
        if (Array.isArray(hueArr) === false) fill = 'white';
        // draw diamond (4-point)
        ctx.translate(px, py);
        ctx.rotate((now/8000 + b.angle) % (Math.PI*2));
        ctx.beginPath();
        ctx.moveTo(0, -size);
        ctx.lineTo(size * 0.6, 0);
        ctx.lineTo(0, size);
        ctx.lineTo(-size * 0.6, 0);
        ctx.closePath();
        // fill + small stroke
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.strokeStyle = `rgba(255,255,255,${0.06})`;
        ctx.lineWidth = 0.6;
        ctx.stroke();
        // outer soft glow using sprite
        ctx.drawImage(glowSprite, -size*5, -size*5, size*10, size*10);
        ctx.setTransform(1,0,0,1,0,0); // reset transform (fast)
      }
      ctx.restore();
    }

    // Shooting stars: ephemeral streaks drawn on FG
    function spawnShootingStar() {
      if (prefersReduced) return;
      // create a shooting star object
      const startY = rand(h * 0.07, h * 0.6);
      const o = {
        x: -0.08 * w,
        y: startY,
        vx: rand(0.9, 2.4) * (w / 1200),
        vy: rand(0.35, 0.9) * (h / 800),
        length: rand(110, 420),
        life: 0,
        duration: rand(0.9, 1.6) * 1000,
        width: rand(1.4, 3.8)
      };
      shootingStars.push(o);
    }

    function updateShooting(delta) {
      // update positions; draw in drawShooting
      for (let i = shootingStars.length - 1; i >= 0; i--) {
        const s = shootingStars[i];
        s.x += s.vx * (delta / 16);
        s.y += s.vy * (delta / 16);
        s.life += delta;
        if (s.life > s.duration + 240) shootingStars.splice(i, 1);
      }
    }

    function drawShooting(ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (let s of shootingStars) {
        const progress = clamp(s.life / s.duration, 0, 1);
        const headX = s.x + s.length * progress;
        const headY = s.y + (s.length * (s.vy / s.vx)) * progress;
        // trail gradient
        const grad = ctx.createLinearGradient(s.x, s.y, headX, headY);
        grad.addColorStop(0, 'rgba(255,255,255,0)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.28)');
        grad.addColorStop(1, 'rgba(255,255,255,0.98)');
        ctx.strokeStyle = grad;
        ctx.lineWidth = s.width;
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(headX, headY);
        ctx.stroke();

        // head glow
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.beginPath();
        ctx.arc(headX, headY, s.width * 2.6, 0, Math.PI*2);
        ctx.fill();

        // faint extra layered glow
        ctx.drawImage(glowSprite, headX - 16, headY - 16, 32, 32);
      }
      ctx.restore();
    }

    // draw loop
    let last = performance.now();
    let rafId = null;
    let lastSpawn = performance.now();
    let shootingTimer = rand(CONFIG.shooting.intervalMin, CONFIG.shooting.intervalMax);

    function frame(now) {
      const delta = now - last;
      last = now;

      // throttle FPS if needed (optional)
      // clear each canvas
      layers.bg.ctx.clearRect(0,0, w, h);
      layers.mid.ctx.clearRect(0,0, w, h);
      layers.fg.ctx.clearRect(0,0, w, h);

      // draw layers
      drawBackground(now, layers.bg.ctx);
      drawTwinkle(now, layers.mid.ctx);
      drawStarBits(now, layers.fg.ctx);

      // shooting stars update/draw on FG
      updateShooting(delta);
      drawShooting(layers.fg.ctx);

      // periodic shooting star spawner
      if (!prefersReduced) {
        if (now - lastSpawn > shootingTimer) {
          if (Math.random() < CONFIG.shooting.chance) spawnShootingStar();
          lastSpawn = now;
          shootingTimer = rand(CONFIG.shooting.intervalMin, CONFIG.shooting.intervalMax);
        }
      }

      rafId = requestAnimationFrame(frame);
    }

    // Mouse/touch parallax for nebula layers (subtle)
    let px = 0, py = 0, tx = 0, ty = 0;
    function onPointer(e) {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const nx = (clientX / window.innerWidth - 0.5) * 2;
      const ny = (clientY / window.innerHeight - 0.5) * 2;
      tx = nx;
      ty = ny;
    }
    function updateParallax() {
      // smooth lerp
      px += (tx - px) * 0.06;
      py += (ty - py) * 0.06;
      if (nebulaBack) nebulaBack.style.transform = `translate(${px*6}px, ${py*3}px) scale(1.04)`;
      if (nebulaMid) nebulaMid.style.transform = `translate(${px*10}px, ${py*5}px) scale(1.02)`;
      if (nebulaFront) nebulaFront.style.transform = `translate(${px*18}px, ${py*8}px) scale(1.01)`;
      requestAnimationFrame(updateParallax);
    }

    // init + attach events
    function start() {
      resize();
      initParticles();
      last = performance.now();
      if (!prefersReduced) rafId = requestAnimationFrame(frame); else {
        // one static render for reduced-motion
        frame(performance.now());
      }

      // pointer parallax when available
      if (!prefersReduced) {
        window.addEventListener('pointermove', onPointer, {passive: true});
        updateParallax();
      }

      // shoot on click/tap (small burst) for interactivity (optional, subtle)
      wrapper.addEventListener('click', (e) => {
        if (prefersReduced) return;
        // spawn a small local burst of starbits near click
        const rect = wrapper.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        for (let i=0;i<6;i++){
          starbits.push({
            cx: cx + rand(-24,24),
            cy: cy + rand(-24,24),
            orbit: rand(8,48),
            angle: Math.random()*Math.PI*2,
            speed: rand(0.002, 0.01),
            size: rand(0.9, 3.2),
            wobble: rand(0.05, 0.5),
            hue: CONFIG.colors.accents[Math.floor(Math.random()*CONFIG.colors.accents.length)],
            extraPulse: Math.random()*Math.PI*2
          });
        }
        // tidy starbits if too many
        if (starbits.length > (CONFIG.starbits.desktop * 3)) starbits.splice(0, 20);
      }, {passive: true});
    }

    // helpers: canvas creation/resizing
    function createCanvas(cls) {
      const canvas = document.createElement('canvas');
      canvas.className = cls;
      canvas.style.position = 'absolute';
      canvas.style.left = '0';
      canvas.style.top = '0';
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.pointerEvents = 'none';
      canvas.style.zIndex = '0';
      // layer z-indexing handled in CSS classes
      const ctx = canvas.getContext('2d', { alpha: true });
      return { canvas, ctx };
    }

    function resizeCanvas(layer, width, height, dpr) {
      const canvas = layer.canvas;
      layer.canvas.style.width = (width) + 'px';
      layer.canvas.style.height = (height) + 'px';
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      // scale drawing context back to device coordinates
      layer.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function createShootingContainer(parent) {
      const el = document.createElement('div');
      el.className = 'shooting-stars';
      el.style.position = 'absolute';
      el.style.inset = 0;
      el.style.pointerEvents = 'none';
      parent.appendChild(el);
      return el;
    }

    // handle resizing & visibility
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        resize();
        initParticles();
      }, 180);
    });

    // pause when hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      } else {
        last = performance.now();
        if (!prefersReduced && !rafId) rafId = requestAnimationFrame(frame);
      }
    });

    // start
    start();

    // cleanup on unload (in SPA-like setups)
    window.addEventListener('beforeunload', () => {
      if (rafId) cancelAnimationFrame(rafId);
      window.removeEventListener('pointermove', onPointer);
    });
  }
})();
</script>
